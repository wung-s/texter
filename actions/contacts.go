package actions

import (
	"fmt"

	"github.com/campaignctrl/textcampaign/models"
	"github.com/gobuffalo/buffalo"
	"github.com/gobuffalo/pop"
	"github.com/gobuffalo/pop/nulls"
	"github.com/gobuffalo/uuid"
	"github.com/pkg/errors"
)

// This file is generated by Buffalo. It offers a basic structure for
// adding, editing and deleting a page. If your model is more
// complex or you need more than the basic implementation you need to
// edit this file.

// Following naming logic is implemented in Buffalo:
// Model: Singular (Contact)
// DB Table: Plural (contacts)
// Resource: Plural (Contacts)
// Path: Plural (/contacts)
// View Template Folder: Plural (/templates/contacts/)

// ContactsResource is the resource for the Contact model
type ContactsResource struct {
	buffalo.Resource
}

// ContactsList gets all Contacts. This function is mapped to the path
// GET /contacts
func ContactsList(c buffalo.Context) error {
	// Get the DB connection from the context
	tx, ok := c.Value("tx").(*pop.Connection)
	if !ok {
		return errors.WithStack(errors.New("no transaction found"))
	}

	contacts := &models.Contacts{}
	q := tx.PaginateFromParams(c.Params())

	// Retrieve all Contacts from the DB
	if err := q.All(contacts); err != nil {
		return errors.WithStack(err)
	}

	result := struct {
		*models.Contacts   `json:"contacts"`
		Page               int `json:"page"`
		PerPage            int `json:"perPage"`
		Offset             int `json:"offset"`
		TotalEntriesSize   int `json:"totalEntriesSize"`
		CurrentEntriesSize int `json:"currentEntriesSize"`
		TotalPages         int `json:"totalPages"`
	}{
		contacts,
		q.Paginator.Page,
		q.Paginator.PerPage,
		q.Paginator.Offset,
		q.Paginator.TotalEntriesSize,
		q.Paginator.CurrentEntriesSize,
		q.Paginator.TotalPages,
	}

	return c.Render(200, r.JSON(result))
}

// Show gets the data for one Contact. This function is mapped to
// the path GET /contacts/{contact_id}
func ContactsShow(c buffalo.Context) error {
	// Get the DB connection from the context
	tx, ok := c.Value("tx").(*pop.Connection)
	if !ok {
		return errors.WithStack(errors.New("no transaction found"))
	}

	// Allocate an empty Contact
	contact := &models.Contact{}

	// To find the Contact the parameter contact_id is used.
	if err := tx.Find(contact, c.Param("contact_id")); err != nil {
		return c.Error(404, err)
	}

	return c.Render(200, r.Auto(c, contact))
}

// ContactParam hold the acceptable parameters for contact
type ContactParam struct {
	FirstName   string
	LastName    string
	PhoneNo     string
	AddGroup    []uuid.UUID
	RemoveGroup []uuid.UUID
}

// ContactsCreate adds a Contact to the DB. This function is mapped to the
// path POST /contacts
func ContactsCreate(c buffalo.Context) error {
	// Allocate an empty Contact
	contactParam := &ContactParam{}

	// Bind contact to the html form elements
	if err := c.Bind(contactParam); err != nil {
		return errors.WithStack(err)
	}

	contact := &models.Contact{
		FirstName: nulls.NewString(contactParam.FirstName),
		LastName:  nulls.NewString(contactParam.LastName),
		PhoneNo:   contactParam.PhoneNo,
	}

	// Get the DB connection from the context
	tx, ok := c.Value("tx").(*pop.Connection)
	if !ok {
		return errors.WithStack(errors.New("no transaction found"))
	}

	fmt.Printf("%+v, %+v", contactParam, contact)

	verrs, err := tx.ValidateAndCreate(contact)
	if err != nil {
		return errors.WithStack(err)
	}

	if verrs.HasAny() {
		return c.Render(422, r.JSON(contact))
	}

	// associate contact with a group
	if len(contactParam.AddGroup) > 0 {
		if err = contact.AssociateWithGroups(tx, contactParam.AddGroup); err != nil {
			return errors.WithStack(err)
		}
	}

	// if (contactParam.GroupID != uuid.UUID{}) {
	// 	if err := contact.AssociateWithGroup(tx, contactParam.GroupID); err != nil {
	// 		return errors.WithStack(err)
	// 	}
	// }

	// and redirect to the contacts index page
	return c.Render(201, r.JSON(contact))
}

// ContactsUpdate changes a Contact in the DB. This function is mapped to
// the path PUT /contacts/{contact_id}
func ContactsUpdate(c buffalo.Context) error {
	// Get the DB connection from the context
	tx, ok := c.Value("tx").(*pop.Connection)
	if !ok {
		return errors.WithStack(errors.New("no transaction found"))
	}

	contactParams := &ContactParam{}

	// Allocate an empty Contact
	contact := &models.Contact{}

	if err := tx.Find(contact, c.Param("contact_id")); err != nil {
		fmt.Println("RETURN 1 !!!!!!")
		return c.Error(404, err)
	}

	// Bind Contact to the html form elements
	if err := c.Bind(contactParams); err != nil {
		return errors.WithStack(err)
	}

	contact.FirstName = nulls.NewString(contactParams.FirstName)
	contact.LastName = nulls.NewString(contactParams.LastName)
	contact.PhoneNo = contactParams.PhoneNo

	verrs, err := tx.ValidateAndUpdate(contact)
	if err != nil {
		return errors.WithStack(err)
	}

	if verrs.HasAny() {
		return c.Render(422, r.Auto(c, contact))
	}

	if len(contactParams.AddGroup) > 0 {
		if err = contact.AssociateWithGroups(tx, contactParams.AddGroup); err != nil {
			return errors.WithStack(err)
		}
	}

	if len(contactParams.RemoveGroup) > 0 {
		if err := contact.DissociateWithGroups(tx, contactParams.RemoveGroup); err != nil {
			return errors.WithStack(err)
		}
	}

	return c.Render(200, r.Auto(c, contact))
}

// Destroy deletes a Contact from the DB. This function is mapped
// to the path DELETE /contacts/{contact_id}
func (v ContactsResource) Destroy(c buffalo.Context) error {
	// Get the DB connection from the context
	tx, ok := c.Value("tx").(*pop.Connection)
	if !ok {
		return errors.WithStack(errors.New("no transaction found"))
	}

	// Allocate an empty Contact
	contact := &models.Contact{}

	// To find the Contact the parameter contact_id is used.
	if err := tx.Find(contact, c.Param("contact_id")); err != nil {
		return c.Error(404, err)
	}

	if err := tx.Destroy(contact); err != nil {
		return errors.WithStack(err)
	}

	// If there are no errors set a flash message
	c.Flash().Add("success", "Contact was destroyed successfully")

	// Redirect to the contacts index page
	return c.Render(200, r.Auto(c, contact))
}

// ContactsSearch perform search on Contacts. This function is mapped to the path
// GET /contacts/search
func ContactsSearch(c buffalo.Context) error {
	// Get the DB connection from the context
	tx, ok := c.Value("tx").(*pop.Connection)
	if !ok {
		return errors.WithStack(errors.New("no transaction found"))
	}

	q := tx.Q()

	contacts := &models.ContactsView{}
	if err := contacts.FilterFromParam(q.PaginateFromParams(c.Params()), c); err != nil {
		return c.Error(404, err)
	}

	// Retrieve all Contacts from the DB
	if err := q.All(contacts); err != nil {
		return errors.WithStack(err)
	}

	result := &struct {
		Contacts           *models.ContactsView `json:"contacts"`
		Page               int                  `json:"page"`
		PerPage            int                  `json:"perPage"`
		Offset             int                  `json:"offset"`
		TotalEntriesSize   int                  `json:"totalEntriesSize"`
		CurrentEntriesSize int                  `json:"currentEntriesSize"`
		TotalPages         int                  `json:"totalPages"`
	}{
		contacts,
		q.Paginator.Page,
		q.Paginator.PerPage,
		q.Paginator.Offset,
		q.Paginator.TotalEntriesSize,
		q.Paginator.CurrentEntriesSize,
		q.Paginator.TotalPages,
	}

	return c.Render(200, r.JSON(result))
}
